## Java的类加载机制 

#### 1. 类加载机制

- 什么是虚拟机的类加载机制

  > 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制

- 怎么进行类加载（类加载的过程）

  ![类的生命周期](https://github.com/Flag2333/TheWayToGod-Java/blob/master/img/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg)

  ##### 1. 加载：生成Class文件

  1. 通过一个类的全限定名来获取定义此类的二进制字节流（数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的）

  2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构

  3. 在内存中声称一个代表这个类的Java.lang.Class对象，作为方法区这个类的各种数据的访问入口

    加载与验证有的时候是交叉进行，加载还没完成，可能就已经在链接，但是一定是先加载后验证

  ##### 2. 验证：验证Class文件

  1. Class文件格式验证
  2. 元数据验证：Class文件里面的内容符合Java语言规范
  3. 字节码验证：确定程序语义正确，没有逻辑问题
  4. 符号引用验证：验证类以外的常量池中的各种符号引用的信息进行匹配性校验，这个校验发生在“解析”这个阶段中将符号引用转化为直接引用时

  ##### 3. 准备：为类分配内存并且设置初始值

  - 分配内存的类不包括实例变量，只包括类变量（被static修饰的变量）
  - 分配地点：方法区

  ##### 4. 解析：把符号引用替换成直接引用

  - 符号引用：一组符号描述所引用的目标，引用的目标不一定已经加载到内存
  - 直接引用：直接指向目标的指针等，引用的目标一定在内存中存在
  - 对同一符号进行多次解析，除invokedynamic指令以外，可以对第一次解析的结果进行缓存；invokedynamic指令用于动态引用，运行期才会知道具体引用的目标是什么

  ##### 5. 初始化：开始执行字节码

  执行类构造器<clinit>() 方法

  - 先执行父类的<clinit>() 方法，再执行子类的
  - 如果类没有静态语句块。也没有对变量的赋值操作可以不生成<clinit>() 方法
  - 接口与类没有静态语句块，但是有变量的赋值操作，会生成<clinit>() 方法，但是接口只有在父接口中定义的变量使用时，父接口才会初始化
  - 接口的实现类在初始化的时候不会执行<clinit>() 方法
  - 多线程同时初始化某个类会造成阻塞

#### 2. 类加载器

- 什么是类加载器

  通过一个类的全限定名来获取描述此类的二进制字节流这个动作的代码块称为“类加载器”

- 类加载器都有哪几种

  1. 启动类加载器：无法被Java程序直接引用
  2. 扩展类加载器：开发者可直接使用
  3. 应用程序类加载器：开发者可直接使用，一般情况下，这个就是程序中默认的类加载器

- 类与类加载器的关系

  类是类加载器加载的，如果要判断两个类是否“相等”，要在这两个类是由同一个类加载器加载的这个大前提下判断

- 双亲委派模型：

  - 什么是双亲委派模型

    ![类加载双亲委派模型](https://github.com/Flag2333/TheWayToGod-Java/blob/master/img/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.jpg)

  - 为什么要用双亲委派模型

    - 如果不用种带有层级关系的模型的话，一个类用不同的加载器加载系统中就会出现多个不同的这个类，具体使用哪个类的话，就不清楚了
    - 用最顶层加载的类，在各种加载器环境都是这同一个类。

  - 双亲委派模型工作过程

    1. 一个类加载器收到加载类的请求，会先把这个请求委派给父类加载器，调用父类加载器的loadClass()方法，直到最顶层
    2. 只有当父类加载器不能加载这个类的时候，抛出异常ClassNotFoundException，子加载器才会自己去加载这个类
    3. 调用自己的findClass() 方法。

  - 破坏双亲委派模型

    1. 双亲委派模型出现之前----JDK 1.2发布之前

       ​	1.2发布之后为了向前兼容添加了findClass() 方法，在之前都是重写loadClass()方法

    2. 需要启动类加载器去加载用户代码，如JNDI服务

       ​	为了解决启动类加载器不能识别用户代码，引入线程上下文类加载器，父类加载器请求子类加载器去加载用户代码，逆向使用类加载器

    3. 代码热替换，模块热部署

       不是双亲委派模型的树状结构，而是网状结构