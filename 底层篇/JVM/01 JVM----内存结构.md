## Java内存结构

#### 1. 运行时数据区

![运行时数据区](https://github.com/Flag2333/TheWayToGod-Java/blob/master/img/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.png)

- 本地方法栈和虚拟机栈所发挥作用相似，区别就是：
  - 虚拟机栈为虚拟机执行Java方法（也就是字节码）服务
  - 本地方法栈为虚拟机使用到的native方法服务
- 异常：
  - 虚拟机栈和本地方法栈中存在的两种异常情况：
    - 如果线程请求的栈的深度大于虚拟机所允许的深度，将抛出**StackOverflowError**异常
    - 虚拟机栈动态扩展的时候，如果无法申请到足够的内存会抛出**OutOfMemoryError**异常
  - 如果在堆中没有内存完成实例分配，并且堆也无法扩展时，将会抛出**OutOfMemoryError**异常
  - 当方法区无法满足内存分配需求时将抛出**OutOfMemoryError**异常，运行时常量池是方法区的一部分，当常量池无法申请到内存时会抛出**OutOfMemoryError**异常

#### 2. 直接内存

> 在JDK 1.4中新加入了NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DircetByteBuffer对象作为这块内存的引用进行操作。

- 作用：提高效率，避免在Java堆和Native堆中来回复制数据
- 服务器管理员在配置虚拟机参数的时候，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，是的各个内存区域总和大于物理内存限制，从而导致动态扩展时出现**OutOfMemoryError**异常

#### 3. 堆与栈的区别

```bash
声明一个引用对象的时候就在堆里开辟一个空间，存放对象实体，把地址赋给栈里的局部变量变量，对象进行初始化过后可以使用。如果当变量等于null的时候，取消引用数据类型的指向 ，这种对象会由垃圾回收机制自动回收。
```

> 堆与栈的区别：
>
> ​            1.栈内存存储的是局部变量而堆内存存储的是实体；
>
> ​            2.栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；
>
> ​            3.栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收。
>
> [堆和栈的概念和区别](https://blog.csdn.net/pt666/article/details/70876410)

#### 4. class文件格式

#### 5. Java中的对象一定在堆上分配吗 

- 逃逸分析中，栈上分配和标量替换可以证明方法和对象不会对外部访问，栈上分配和标量替换的对象是在栈上分配的